# Clang Moudules

在iOS工程，Build Settings, Apple Clang-Language-Module下有一个Enable Modules (C and Objective-C)选项， 这个选项创建工程后是默认打开的。

在更早的时候，我们引入其他库的文件时使用#import, #include， 打开这个选项之后，我们可以使用@import来直接引入一个模块。例如：@import UIKit

Modules是原有引用方式的改进方案，那Modules解决了什么问题，又有什么问题是模块无法解决的？


## 原有预处理器包含模型的缺点

* 编译的可扩展性： 当一个头文件被包含时，编译器需要对该头文件，以及该头文件所包含的所有头文件进行预编译和语法分析，应用中的每个编译单元都需要重复这些操作，产生了大量的冗余工作。假设应用中有N个编译单元，每个编译单元包含了M个头文件，编译器需要处理M*N次，即使这M个头文件在不同的编译单元里都是共享的。这种问题在C++中尤为明显，因为模板的编译模型迫使代码引用了大量的头文件。

* 脆弱性：预处理器把 #include 当中文本包含来处理，因此在引用头文件时会受到任何活动宏定义的约束。如果有活动宏定义和库中宏定义命名冲突，则可能破坏库的API或者导致该库头文件编译失败。例如： #define std "The C++ Standard" 并包含C++标准库头文件，会导致C++标准库实现中的一系列可怕的失败。当两个不同库的头文件由于宏冲突而产生交互时，会出现更微妙的实际问题，用户被迫重新排序#include指令或引入#undef指令以打破（意外的）依赖关系。

* 传统的解决方法：C程序员采用了许多约定来解决C预处理器模型的脆弱性。例如，大多数头文件都需要使用include guard，以确保多重包含不会破坏编译。宏名称使用长前缀大写标识符编写，以避免冲突，一些库/框架开发人员甚至在头文件中使用带下划线的名称，以避免与（按照惯例）不应该是宏的“普通”名称发生冲突。这些约定是来自非C语言的开发人员进入的障碍，是经验丰富的开发人员的样板，并且使我们的头文件比它们应有的样子要难看得多。

* 工具混淆：在基于C的语言中，很难构建与软件库配合良好的工具，因为库的边界不明确。哪些头属于特定的库，以及应该以什么顺序包含这些头以保证它们正确编译？标题是C、C++、Objective-C++，还是这些语言的变体之一？这些头文件中的哪些声明实际上是API的一部分，哪些声明仅因为必须作为头文件的一部分编写而存在？

## Modules的优点

Modules其实是一种语义引入模型，通过将文本预处理器包含模型替换为更健壮、更高效的语义模型，改进了对软件库API的访问。从用户的角度来看，代码看起来只是略有不同，因为使用导入声明而不是#include预处理器指令：

```
import std.io; //Objective-C 使用 @import

```

但是，Modules的导入的行为与相应的#include<stdio.h>截然不同：当编译器看到上面的模块导入时，它将加载std.io模块的二进制表示，并使其API直接可供应用程序使用。导入声明之前的预处理器定义对std.io提供的API没有影响，因为模块本身被编译为单独的独立模块。此外，在导入模块时，将自动提供使用std.io模块所需的任何链接器标志。此语义导入模型解决了预处理器包含模型的许多问题：


* 编译的可扩展性：每个模块只编译一次，将模块导入翻译单元是一个恒定时间操作（独立于模块系统）。因此，每个软件库的API只解析一次，从而将M*N编译问题简化为M+N问题。

* 脆弱性：每个模块都被解析为一个独立的实体，因此它有一个一致的预处理器环境。这完全消除了使用带下划线的名字和类似的防御技巧的需要。此外，当遇到导入声明时，会忽略当前的预处理器定义，因此一个软件库不能影响另一个软件库的编译方式，从而消除包含顺序依赖关系。

* 工具混淆：模块描述了软件库的API，工具可以推理并将模块表示为该API。因为模块只能独立构建，所以工具可以依赖模块定义来确保获得库的完整API。此外，模块可以指定他们使用哪些语言，因此，例如，人们不会意外地尝试将C++模块加载到C程序中。

## Modules不能解决的问题

许多编程语言都有一个模块或包系统，由于这些语言提供了各种各样的功能，因此定义模块不做什么很重要。特别是，以下所有内容均被视为超出模块范围：

* 代码重写：要求应用程序或软件库进行剧烈或不向后兼容的更改是不现实的，完全删除头也是不可行的。模块必须与现有软件库互操作，并允许逐步过渡。

* 版本控制： 模块没有版本信息的概念。程序员仍然必须依赖基础语言（如果存在）的现有版本控制机制来对软件库进行版本控制。

* 命名空间： 与某些语言不同，模块不包含任何命名空间的概念。因此，在一个模块中声明的结构仍然会与在不同模块中声明的同名结构冲突，就像在两个不同的头中声明一样。这一方面对于向后兼容性很重要，因为（例如）引入模块时，软件库中符号重整名称不得更改。

* 模块的二进制发布：头文件（特别是C++头）暴露了语言的全部复杂性。在架构、编译器版本和编译器供应商之间保持稳定的二进制模块格式在技术上是不可行的。

参考文档: https://clang.llvm.org/docs/Modules.html#semantic-import

